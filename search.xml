<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>栈与队列</title>
      <link href="/2023/01/12/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2023/01/12/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="栈与队列理论基础"><a href="#栈与队列理论基础" class="headerlink" title="栈与队列理论基础"></a>栈与队列理论基础</h3><ol><li>栈和队列也是SGI STL里面的数据结构，栈后进先出，队列先进先出，栈和队列都不提供迭代器</li><li>SGI STL中 栈和队列的底层实现缺省的情况下都是用 deque 双端队列实现的</li></ol><h3 id="栈与队列中常见的面试题型"><a href="#栈与队列中常见的面试题型" class="headerlink" title="栈与队列中常见的面试题型"></a>栈与队列中常见的面试题型</h3><ol><li>利用栈和队列的性质解题</li><li>单调栈</li><li>单调队列</li><li>优先队列</li></ol><h4 id="leetcode-232-用栈实现队列"><a href="#leetcode-232-用栈实现队列" class="headerlink" title="leetcode.232 用栈实现队列"></a>leetcode.232 用栈实现队列</h4><ul><li>链接<a href="https://leetcode.cn/problems/implement-queue-using-stacks/">https://leetcode.cn/problems/implement-queue-using-stacks/</a>  </li><li>解题方法：利用栈和队列的性质</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyQueue &#123;</span><br><span class="line">public:</span><br><span class="line">    stack&lt;int&gt; a, b;</span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        a.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int pop() &#123;</span><br><span class="line">        // 保留一个元素用来返回答案</span><br><span class="line">        while (a.size() &gt; 1) b.push(a.top()), a.pop();</span><br><span class="line">        int cur = a.top();</span><br><span class="line">        a.pop();</span><br><span class="line">        // 恢复现场</span><br><span class="line">        while (b.size()) a.push(b.top()), b.pop();</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int peek() &#123;</span><br><span class="line">        while (a.size() &gt; 1) b.push(a.top()), a.pop();</span><br><span class="line">        int cur = a.top();</span><br><span class="line">        while (b.size()) a.push(b.top()), b.pop();</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return a.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="line"> * MyQueue* obj = new MyQueue();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * int param_2 = obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;peek();</span><br><span class="line"> * bool param_4 = obj-&gt;empty();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-225-用队列实现栈"><a href="#leetcode-225-用队列实现栈" class="headerlink" title="leetcode.225 用队列实现栈"></a>leetcode.225 用队列实现栈</h4><ul><li>链接<a href="https://leetcode.cn/problems/implement-stack-using-queues/">https://leetcode.cn/problems/implement-stack-using-queues/</a>  </li><li>解题方法：<br>在获取队头元素的时候和上一题有所区别</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">public:</span><br><span class="line">    queue&lt;int&gt; a, b;</span><br><span class="line">    MyStack() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        a.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int pop() &#123;</span><br><span class="line">        while (a.size() &gt; 1) b.push(a.front()), a.pop();</span><br><span class="line">        int cur = a.front();</span><br><span class="line">        a.pop();</span><br><span class="line">        while (b.size()) a.push(b.front()), b.pop();</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123;</span><br><span class="line">        while (a.size() &gt; 1) b.push(a.front()), a.pop();</span><br><span class="line">        int cur = a.front();</span><br><span class="line">        a.pop();</span><br><span class="line">        while (b.size()) a.push(b.front()), b.pop();</span><br><span class="line">        a.push(cur);</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return a.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyStack object will be instantiated and called as such:</span><br><span class="line"> * MyStack* obj = new MyStack();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * int param_2 = obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;top();</span><br><span class="line"> * bool param_4 = obj-&gt;empty();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-20-有效的括号"><a href="#leetcode-20-有效的括号" class="headerlink" title="leetcode.20 有效的括号"></a>leetcode.20 有效的括号</h4><ul><li>链接<a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a>  </li><li>解题方法1：先将所有的左括号入栈，注意入栈顺序要跟匹配顺序相同<br>匹配右括号，如果栈为空或不能够匹配当前括号则返回false</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        stack&lt;char&gt; stk;</span><br><span class="line">        for (auto c: s)&#123;</span><br><span class="line">            if (c == &#x27;(&#x27; || c == &#x27;[&#x27; || c == &#x27;&#123;&#x27;) stk.push(c);</span><br><span class="line">            else if (c == &#x27;)&#x27;)&#123;</span><br><span class="line">                if (stk.empty() || stk.top() != &#x27;(&#x27;)</span><br><span class="line">                    return false;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            else if (c == &#x27;]&#x27;)&#123;</span><br><span class="line">                if (stk.empty() || stk.top() != &#x27;[&#x27;)</span><br><span class="line">                    return false;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            else if (c == &#x27;&#125;&#x27;)&#123;</span><br><span class="line">                if (stk.empty() || stk.top() != &#x27;&#123;&#x27;)</span><br><span class="line">                    return false;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>解题方法2：先将所有的左括号入栈，注意入栈顺序要跟匹配顺序相同<br>匹配右括号，可以查询 ASKII 码发现无论是大中小括号，其左右括号的 ASKII 码相差小于等于 2</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        stack&lt;char&gt; stk;</span><br><span class="line">        for (auto c: s)&#123;</span><br><span class="line">            if (c == &#x27;(&#x27; || c == &#x27;[&#x27; || c == &#x27;&#123;&#x27;) stk.push(c);</span><br><span class="line">            else &#123;</span><br><span class="line">                if (stk.empty() || abs(c - stk.top()) &gt; 2) return false;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-1047-删除字符串中的所有相邻重复项"><a href="#leetcode-1047-删除字符串中的所有相邻重复项" class="headerlink" title="leetcode.1047 删除字符串中的所有相邻重复项"></a>leetcode.1047 删除字符串中的所有相邻重复项</h4><ul><li>链接<a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/</a>  </li><li>解题方法：遍历所有字符，如果栈不空且栈顶元素与遍历的当前元素相同，删除栈顶元素，否则将当前元素加入栈中<br>遍历栈加入答案数组，由于栈是先入后出所以需要反转一下答案数组</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string removeDuplicates(string s) &#123;</span><br><span class="line">        stack&lt;char&gt; stk;</span><br><span class="line">        string res;</span><br><span class="line">        for (auto c: s)&#123;</span><br><span class="line">            if (stk.size() &amp;&amp; stk.top() == c) stk.pop();</span><br><span class="line">            else stk.push(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (stk.size())&#123;</span><br><span class="line">            res += stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-150-逆波兰表达式求值"><a href="#leetcode-150-逆波兰表达式求值" class="headerlink" title="leetcode.150 逆波兰表达式求值"></a>leetcode.150 逆波兰表达式求值</h4><ul><li>链接<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/</a>  </li><li>解题方法：遍历所有字符，如果字符为运算符则将当前栈顶的两个元素弹出做相应计算（注意：弹出是先弹出后面的元素，减法和除法需要注意元素计算顺序）<br>如果字符为数字，则入栈（注意转换格式）</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        for (auto c: tokens)&#123;</span><br><span class="line">            if (c == &quot;+&quot; || c == &quot;-&quot; || c == &quot;*&quot; || c == &quot;/&quot;)&#123;</span><br><span class="line">                long b = stk.top(); stk.pop();</span><br><span class="line">                long a = stk.top(); stk.pop();</span><br><span class="line">                if (c == &quot;+&quot;) stk.push(a + b);</span><br><span class="line">                else if (c == &quot;-&quot;) stk.push(a - b);</span><br><span class="line">                else if (c == &quot;*&quot;) stk.push(a * b);</span><br><span class="line">                else if (c == &quot;/&quot;) stk.push(a / b);</span><br><span class="line">            &#125;</span><br><span class="line">            else stk.push(stoi(c));</span><br><span class="line">        &#125;</span><br><span class="line">        return stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><ul><li>常见模型：找出每个数左边&#x2F;右边离它最近的比它大&#x2F;小的数</li><li>单调栈模板<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; n; i ++ )// 根据题目调整遍历顺序</span><br><span class="line">&#123;</span><br><span class="line">    while (stk.size() &amp;&amp; check(stk[tt], i))&#123;</span><br><span class="line">        // </span><br><span class="line">    &#125;</span><br><span class="line">    stk.push();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Acwing-830-单调栈"><a href="#Acwing-830-单调栈" class="headerlink" title="Acwing.830 单调栈"></a>Acwing.830 单调栈</h4><ul><li>链接<a href="https://www.acwing.com/problem/content/832/">https://www.acwing.com/problem/content/832/</a></li></ul><p>给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</p><p><strong>输入格式</strong><br>第一行包含整数 N，表示数列长度。</p><p>第二行包含 N 个整数，表示整数数列。</p><p><strong>输出格式</strong><br>共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。</p><p><strong>数据范围</strong><br>1 $\leq$ N $\leq$ $10^{5}$<br>1 $\leq$ 数列中元素 $\leq$ $10^{9}$  </p><p><strong>输入样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 7 5</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 3 -1 2 2</span><br></pre></td></tr></table></figure><ul><li>解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5 + 10;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int nums[N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 0; i &lt; n; i ++) cin &gt;&gt; nums[i];</span><br><span class="line">    </span><br><span class="line">    stack&lt;int&gt; stk;</span><br><span class="line">    for (int i = 0; i &lt; n; i ++)&#123;</span><br><span class="line">        while (stk.size() &amp;&amp; nums[i] &lt;= stk.top()) stk.pop();</span><br><span class="line">        if (stk.size()) cout &lt;&lt; stk.top() &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        else cout &lt;&lt; -1 &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        stk.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-739-每日温度"><a href="#leetcode-739-每日温度" class="headerlink" title="leetcode.739 每日温度"></a>leetcode.739 每日温度</h4><ul><li>链接<a href="https://leetcode.cn/problems/daily-temperatures/">https://leetcode.cn/problems/daily-temperatures/</a>  </li><li>解题方法：单调栈模板</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; t) &#123;</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        vector&lt;int&gt; res(t.size());</span><br><span class="line">        for (int i = t.size() - 1; i &gt;= 0; i --)&#123;</span><br><span class="line">            while (stk.size() &amp;&amp; t[i] &gt;= t[stk.top()]) stk.pop();</span><br><span class="line">            if (stk.size()) res[i] = stk.top() - i;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-496-下一个更大元素-I"><a href="#leetcode-496-下一个更大元素-I" class="headerlink" title="leetcode.496 下一个更大元素 I"></a>leetcode.496 下一个更大元素 I</h4><ul><li>链接<a href="https://leetcode.cn/problems/next-greater-element-i/">https://leetcode.cn/problems/next-greater-element-i/</a>  </li><li>解题方法：单调栈模板</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        vector&lt;int&gt; q(nums2.size());</span><br><span class="line">        // 找到nums2中每个数的下一个更大元素，存在数组q中</span><br><span class="line">        for (int i = nums2.size() - 1; i &gt;= 0; i --)&#123;</span><br><span class="line">            while (stk.size() &amp;&amp; nums2[i] &gt;= stk.top()) stk.pop();</span><br><span class="line">            if (stk.size()) q[i] = stk.top();</span><br><span class="line">            else q[i] = -1;</span><br><span class="line">            stk.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        // 用哈希表存nums2中每个元素的下标</span><br><span class="line">        unordered_map&lt;int, int&gt; hash;</span><br><span class="line">        for (int i = 0; i &lt; nums2.size(); i ++) hash[nums2[i]] = i;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        // 找到nums1中元素在nums2中对应的下标，将数组q中的值取出来即为答案</span><br><span class="line">        for (auto c: nums1)&#123;</span><br><span class="line">            res.push_back(q[hash[c]]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-503-下一个更大元素-II"><a href="#leetcode-503-下一个更大元素-II" class="headerlink" title="leetcode.503 下一个更大元素 II"></a>leetcode.503 下一个更大元素 II</h4><ul><li>链接<a href="https://leetcode.cn/problems/next-greater-element-ii/">https://leetcode.cn/problems/next-greater-element-ii/</a>  </li><li>解题方法：解决环形问题，可以将数组复制一份接到原数组之后<br>同样用单调栈模板解题</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        vector&lt;int&gt; res(n * 2);</span><br><span class="line">        nums.insert(nums.end(), nums.begin(), nums.end());</span><br><span class="line">        for (int i = n * 2 - 1; i &gt;= 0; i --)&#123;</span><br><span class="line">            while (stk.size() &amp;&amp; nums[i] &gt;= stk.top()) stk.pop();</span><br><span class="line">            if (stk.size()) res[i] = stk.top();</span><br><span class="line">            else res[i] = -1;</span><br><span class="line">            stk.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.resize(n);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><ul><li>常见模型：找出滑动窗口中的最大&#x2F;最小值</li><li>如果求滑动窗口的最大值那么即为一个递减序列（队头为最大值）</li><li>如果求滑动窗口的最小值那么即为一个递增序列（队头为最小值）</li><li>单调队列模板<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    // 合法性判断（是否超出滑动窗口的大小）</span><br><span class="line">    while (q.size() &amp;&amp; check()) q.pop_front();  // 判断队头是否滑出窗口</span><br><span class="line">    // 单调性判断（添加的元素是否符合队列单调性）</span><br><span class="line">    while (q.size() &amp;&amp; check()) q.pop_back();</span><br><span class="line">    // 在队尾添加元素</span><br><span class="line">    q.push_back(i);</span><br><span class="line">    // 能够形成滑动窗口了开始维护答案</span><br><span class="line">    if (i &gt;= k - 1) res.push_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Acwing-154-滑动窗口"><a href="#Acwing-154-滑动窗口" class="headerlink" title="Acwing.154 滑动窗口"></a>Acwing.154 滑动窗口</h4><ul><li>链接<a href="https://www.acwing.com/problem/content/156/">https://www.acwing.com/problem/content/156/</a></li></ul><p>给定一个大小为 n $\leq$ $10^{6}$ 的数组。</p><p>有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。</p><p>你只能在窗口中看到 k 个数字。</p><p>每次滑动窗口向右移动一个位置。</p><p>以下是一个例子：</p><p>该数组为 [1 3 -1 -3 5 3 6 7]，k 为 3。<br>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p><p><strong>输入格式</strong><br>输入包含两行。</p><p>第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。</p><p>第二行有 n 个整数，代表数组的具体数值。</p><p>同行数据之间用空格隔开。</p><p><strong>输出格式</strong><br>输出包含两个。</p><p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p><p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p><p><strong>输入样例：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 3  </span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure><ul><li>解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e6 + 10;</span><br><span class="line"></span><br><span class="line">int n, k;</span><br><span class="line">int nums[N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    for (int i = 0; i &lt; n; i ++) cin &gt;&gt; nums[i];</span><br><span class="line">    </span><br><span class="line">    deque&lt;int&gt; q1;</span><br><span class="line">    for (int i = 0; i &lt; n; i ++)&#123;</span><br><span class="line">        if (q1.size() &amp;&amp; i - q1.front() + 1 &gt; k) q1.pop_front();</span><br><span class="line">        while (q1.size() &amp;&amp; nums[i] &lt;= nums[q1.back()]) q1.pop_back();</span><br><span class="line">        q1.push_back(i);</span><br><span class="line">        if (i &gt;= k - 1) cout &lt;&lt; nums[q1.front()] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    puts(&quot;&quot;);</span><br><span class="line">    deque&lt;int&gt; q2;</span><br><span class="line">    for (int i = 0; i &lt; n; i ++)&#123;</span><br><span class="line">        if (q2.size() &amp;&amp; i - q2.front() + 1 &gt; k) q2.pop_front();</span><br><span class="line">        while (q2.size() &amp;&amp; nums[i] &gt;= nums[q2.back()]) q2.pop_back();</span><br><span class="line">        q2.push_back(i);</span><br><span class="line">        if (i &gt;= k - 1) cout &lt;&lt; nums[q2.front()] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-239-滑动窗口最大值"><a href="#leetcode-239-滑动窗口最大值" class="headerlink" title="leetcode.239 滑动窗口最大值"></a>leetcode.239 滑动窗口最大值</h4><ul><li>链接<a href="https://leetcode.cn/problems/sliding-window-maximum/">https://leetcode.cn/problems/sliding-window-maximum/</a>  </li><li>解题方法：单调队列模板</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        deque&lt;int&gt; q;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i ++)&#123;</span><br><span class="line">            while (q.size() &amp;&amp; i - q.front() + 1 &gt; k) q.pop_front();</span><br><span class="line">            while (q.size() &amp;&amp; nums[i] &gt;= nums[q.back()]) q.pop_back();</span><br><span class="line">            q.push_back(i);</span><br><span class="line">            if (i &gt;= k - 1) res.push_back(nums[q.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><ul><li>优先队列是一种会按照默认或自定义的优先级进行自动排序的队列，其特点是优先级高的元素排在队首，低的排在队尾，可以理解为维护一个堆</li><li>头文件<code>#include &lt;queue&gt;</code>中提供了两种可直接引用的优先规则（排序规则）：greater、less；其中，less 是默认优先规则，小的元素排在堆底，大的元素在堆顶也叫大根堆；greater 表示小根堆，大的元素排在堆底，小的元素在堆顶</li></ul><h4 id="leetcode-215-数组中的第-K-个最大元素"><a href="#leetcode-215-数组中的第-K-个最大元素" class="headerlink" title="leetcode.215 数组中的第 K 个最大元素"></a>leetcode.215 数组中的第 K 个最大元素</h4><ul><li>链接<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">https://leetcode.cn/problems/kth-largest-element-in-an-array/</a>  </li><li>解题方法：代码注释</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        // 优先队列，建小根堆即堆顶元素为最小值，这样更新的时候可以删除堆顶元素</span><br><span class="line">        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;</span><br><span class="line">        // 直接入堆，如果大于 k 则删除元素（删除的都是最小值）</span><br><span class="line">        for (auto c: nums)&#123;</span><br><span class="line">            heap.push(c);</span><br><span class="line">            if (heap.size() &gt; k)&#123;</span><br><span class="line">                heap.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 输出</span><br><span class="line">        return heap.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-347-前-K-个高频元素"><a href="#leetcode-347-前-K-个高频元素" class="headerlink" title="leetcode.347 前 K 个高频元素"></a>leetcode.347 前 K 个高频元素</h4><ul><li>链接<a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a>  </li><li>解题方法：代码注释</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        // 用哈希表记录每个数字出现的次数</span><br><span class="line">        unordered_map&lt;int, int&gt; hash;</span><br><span class="line">        for (auto c: nums) hash[c] ++;</span><br><span class="line">        // 重载优先队列排序，pair&lt;数字，出现的次数&gt;，以数字出现的次数排序</span><br><span class="line">        struct mycompare&#123;</span><br><span class="line">            bool operator () (const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b)&#123;</span><br><span class="line">            return a.second &gt; b.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 定义优先队列</span><br><span class="line">        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, mycompare&gt; heap;</span><br><span class="line">        // 将哈希表入队，如果元素个数超过 k 则删除堆顶元素（最小值）</span><br><span class="line">        for (auto x: hash)&#123;</span><br><span class="line">            heap.push(x);</span><br><span class="line">            if (heap.size() &gt; k)&#123;</span><br><span class="line">                heap.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 输出结果，输出的是 pair 中的数字</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        while (heap.size())&#123;</span><br><span class="line">            res.push_back(heap.top().first);</span><br><span class="line">            heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-23-合并-K-个升序链表"><a href="#leetcode-23-合并-K-个升序链表" class="headerlink" title="leetcode.23 合并 K 个升序链表"></a>leetcode.23 合并 K 个升序链表</h4><ul><li>链接<a href="https://leetcode.cn/problems/merge-k-sorted-lists/">https://leetcode.cn/problems/merge-k-sorted-lists/</a>  </li><li>解题方法：归并排序    </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 重载比较函数，将小的元素放在堆顶，大的元素放在堆底</span><br><span class="line">    struct Cmp&#123;</span><br><span class="line">        bool operator() (ListNode* a, ListNode* b)&#123;</span><br><span class="line">            return a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, Cmp&gt; heap;</span><br><span class="line">        auto dummy = new ListNode(-1);</span><br><span class="line">        auto cur = dummy;</span><br><span class="line">        // 将所有链表数组入堆，会自动排序将头元素进行排序</span><br><span class="line">        for (auto c: lists) </span><br><span class="line">            if (c) heap.push(c);</span><br><span class="line"></span><br><span class="line">        while (heap.size())&#123;</span><br><span class="line">            auto t = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next = t;</span><br><span class="line">            if (t-&gt;next) heap.push(t-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2023/01/11/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2023/01/11/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h3><ol><li>哈希表是根据关键码的值而直接进行访问的数据结构，又叫做散列表，一般哈希表都是用来快速判断一个元素是否出现集合里</li><li>解决哈希碰撞有两种方法：拉链法，开放寻址法</li><li>常见的哈希结构（c++）set 和 map</li></ol><table><thead><tr><th align="left">集合</th><th align="left">底层实现</th><th align="left">是否有序</th><th align="left">数值是否可以重复</th><th align="left">查询效率</th><th align="left">增删效率</th></tr></thead><tbody><tr><td align="left">std::set</td><td align="left">红黑树</td><td align="left">有序</td><td align="left">否</td><td align="left">O(log n)</td><td align="left">O(log n)</td></tr><tr><td align="left">std::multiset</td><td align="left">红黑树</td><td align="left">有序</td><td align="left">是</td><td align="left">O(logn)</td><td align="left">O(logn)</td></tr><tr><td align="left">std::unordered_set</td><td align="left">哈希表</td><td align="left">无序</td><td align="left">否</td><td align="left">O(1)</td><td align="left">O(1)</td></tr></tbody></table><p>std::unordered_set 底层实现为哈希表，std::set 和 std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><table><thead><tr><th align="left">映射</th><th align="left">底层实现</th><th align="left">是否有序</th><th align="left">key是否可以重复</th><th align="left">查询效率</th><th align="left">增删效率</th></tr></thead><tbody><tr><td align="left">std::map</td><td align="left">红黑树</td><td align="left">key有序</td><td align="left">否</td><td align="left">O(log n)</td><td align="left">O(log n)</td></tr><tr><td align="left">std::multimap</td><td align="left">红黑树</td><td align="left">key有序</td><td align="left">是</td><td align="left">O(logn)</td><td align="left">O(logn)</td></tr><tr><td align="left">std::unordered_map</td><td align="left">哈希表</td><td align="left">key无序</td><td align="left">否</td><td align="left">O(1)</td><td align="left">O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的  </p><p><strong>使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset</strong></p><h3 id="哈希表中常见的面试题型"><a href="#哈希表中常见的面试题型" class="headerlink" title="哈希表中常见的面试题型"></a>哈希表中常见的面试题型</h3><ol><li>利用哈希表（map，set）的性质解题</li><li>双指针算法（滑动窗口）（见双指针算法总结）</li></ol><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="leetcode-242-有效的字母异位词"><a href="#leetcode-242-有效的字母异位词" class="headerlink" title="leetcode.242 有效的字母异位词"></a>leetcode.242 有效的字母异位词</h4><ul><li>链接<a href="https://leetcode.cn/problems/valid-anagram/">https://leetcode.cn/problems/valid-anagram/</a>  </li><li>解题方法：哈希表<br>将两个字符串存入两个哈希表并记录每个字符出现的次数<br>每个字符出现的次数相等则返回 true，否则返回 false</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123;</span><br><span class="line">        unordered_map&lt;char, int&gt; a, b;</span><br><span class="line">        for (auto c: s) a[c] ++;</span><br><span class="line">        for (auto c: t) b[c] ++;</span><br><span class="line">        return a == b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-383-赎金信"><a href="#leetcode-383-赎金信" class="headerlink" title="leetcode.383 赎金信"></a>leetcode.383 赎金信</h4><ul><li>链接<a href="https://leetcode.cn/problems/ransom-note/">https://leetcode.cn/problems/ransom-note/</a>  </li><li>解题方法：哈希表<br>将字符串 b 存入哈希表，如果字符串 a 中出现了哈希表中没有的字符直接返回 false<br>如果出现了哈希表中存在的字符则哈希表的 value-1</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canConstruct(string ransomNote, string magazine) &#123;</span><br><span class="line">        unordered_map&lt;char, int&gt; hash;</span><br><span class="line">        for (auto c: magazine) hash[c] ++;</span><br><span class="line">        for (auto c: ransomNote)&#123;</span><br><span class="line">            if (!hash[c]) return false;</span><br><span class="line">            hash[c] --;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-1-两数之和"><a href="#leetcode-1-两数之和" class="headerlink" title="leetcode.1 两数之和"></a>leetcode.1 两数之和</h4><ul><li>链接<a href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum/</a>  </li><li>解题方法：哈希表<br>将数组元素存入哈希表，遍历数组求差，差值如果在哈希表中存在则返回下标</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; hash;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i ++)&#123;</span><br><span class="line">            int cur = target - nums[i];</span><br><span class="line">            if (hash.count(cur)) return &#123;hash[cur], i&#125;;</span><br><span class="line">            hash[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-454-四数相加-II"><a href="#leetcode-454-四数相加-II" class="headerlink" title="leetcode.454 四数相加 II"></a>leetcode.454 四数相加 II</h4><ul><li>链接<a href="https://leetcode.cn/problems/4sum-ii/">https://leetcode.cn/problems/4sum-ii/</a>  </li><li>解题方法：哈希表<br><code>a+b+c+d = 0 =&gt; a+b=-(c+d)</code><br>遍历 nums1 nums2 将 a+b 的和 x 存入哈希表，遍历 nums3 nums4 哈希表中有多少个 -x 就说明有多少个符合条件的组合</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; hash;</span><br><span class="line">        int res = 0;</span><br><span class="line"></span><br><span class="line">        for (auto a: nums1)</span><br><span class="line">            for (auto b: nums2)</span><br><span class="line">                hash[a + b] ++;</span><br><span class="line">        </span><br><span class="line">        for (auto c: nums3)</span><br><span class="line">            for (auto d:nums4)</span><br><span class="line">                res += hash[-(c + d)];</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-49-字母异位词分组"><a href="#leetcode-49-字母异位词分组" class="headerlink" title="leetcode.49 字母异位词分组"></a>leetcode.49 字母异位词分组</h4><ul><li>链接<a href="https://leetcode.cn/problems/group-anagrams/">https://leetcode.cn/problems/group-anagrams/</a>  </li><li>解题方法：哈希表<br>哈希表中存{key:[“”,””,””]}<br>例如{“abc”:[“abc”,”acb”,”cba”]}<br>将所有的字符串按字典序排序，如果是字母异位词则一定有相同的字典序<br>如”abc”,”acb”,”cba”它们的字典序都是”abc”<br>key 存字典序，value 存有相同字典序的字符串</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; hash;// &#123;&quot;abc&quot;:[&quot;abc&quot;,[acb],[cab]]&#125;</span><br><span class="line">        </span><br><span class="line">        for (auto str: strs)&#123;</span><br><span class="line">            auto c = str;</span><br><span class="line">            sort(c.begin(), c.end());// 将所有字符串按字典序排序</span><br><span class="line">            hash[c].push_back(str);// 按照字典序把字符串存入哈希表</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        for (auto c: hash) res.push_back(c.second);// 将hash中的value拿出来</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h3><h4 id="leetcode-349-两个数组的交集"><a href="#leetcode-349-两个数组的交集" class="headerlink" title="leetcode.349 两个数组的交集"></a>leetcode.349 两个数组的交集</h4><ul><li>链接<a href="https://leetcode.cn/problems/intersection-of-two-arrays/">https://leetcode.cn/problems/intersection-of-two-arrays/</a>  </li><li>解题方法：哈希集合<br>unordered_set不包含重复元素，key&#x3D;value<br>将 num1 中的元素加入集合中，遍历 nums2 中的元素，如果集合中有相同的元素说明是交集，加入答案数组，并把当前元素从集合中删除</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; set;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">        for (auto c: nums1) set.insert(c);</span><br><span class="line">        for (auto c: nums2)&#123;</span><br><span class="line">            if (set.count(c))&#123;</span><br><span class="line">                res.push_back(c);</span><br><span class="line">                set.erase(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-350-两个数组的交集-II"><a href="#leetcode-350-两个数组的交集-II" class="headerlink" title="leetcode.350 两个数组的交集 II"></a>leetcode.350 两个数组的交集 II</h4><ul><li>链接<a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/submissions/">https://leetcode.cn/problems/intersection-of-two-arrays-ii/submissions/</a>  </li><li>解题方法：哈希集合<br>unordered_multiset可以包含重复元素，key&#x3D;value<br>和上一题思路类似</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_multiset&lt;int&gt; mtset;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">        for (auto c: nums1) mtset.insert(c);</span><br><span class="line">        for (auto c: nums2)&#123;</span><br><span class="line">            if (mtset.count(c))&#123;</span><br><span class="line">                res.push_back(c);</span><br><span class="line">                mtset.erase(mtset.find(c));// 只删除一个c</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-202-快乐数"><a href="#leetcode-202-快乐数" class="headerlink" title="leetcode.202 快乐数"></a>leetcode.202 快乐数</h4><ul><li>链接<a href="https://leetcode.cn/problems/happy-number/submissions/">https://leetcode.cn/problems/happy-number/submissions/</a>  </li><li>解题方法：哈希集合<br>通过集合判断一个数是否重复出现过，如果重复出现说明这个数陷入了循环直接返回 false，否则返回 true</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; set;</span><br><span class="line"></span><br><span class="line">        while (n != 1)&#123;</span><br><span class="line">            int res = 0;</span><br><span class="line">            while (n)&#123;</span><br><span class="line">                res += (n % 10) * (n % 10);</span><br><span class="line">                n /= 10;</span><br><span class="line">            &#125;</span><br><span class="line">            if (set.count(res)) return false;</span><br><span class="line">            set.insert(res);</span><br><span class="line">            n = res;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2023/01/11/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/01/11/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="字符串理论基础"><a href="#字符串理论基础" class="headerlink" title="字符串理论基础"></a>字符串理论基础</h3><ul><li>字符串是若干字符组成的有限序列，也可以理解为是一个字符数组</li></ul><h3 id="数组中常见的面试题型"><a href="#数组中常见的面试题型" class="headerlink" title="数组中常见的面试题型"></a>数组中常见的面试题型</h3><ol><li>暴力枚举</li><li>双指针算法（见双指针算法总结）</li><li>KMP算法</li></ol><h4 id="剑指offer-05-替换空格"><a href="#剑指offer-05-替换空格" class="headerlink" title="剑指offer.05 替换空格"></a>剑指offer.05 替换空格</h4><ul><li>链接<a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">https://leetcode.cn/problems/ti-huan-kong-ge-lcof/</a>  </li><li>解题方法：创建字符串，遍历原字符串找到空格替换即可</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string replaceSpace(string s) &#123;</span><br><span class="line">        string res;</span><br><span class="line">        for (auto c: s)&#123;</span><br><span class="line">            if (c == &#x27; &#x27;)&#123;</span><br><span class="line">                res += &quot;%20&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            else res += c;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-58-最后一个单词的长度"><a href="#leetcode-58-最后一个单词的长度" class="headerlink" title="leetcode.58 最后一个单词的长度"></a>leetcode.58 最后一个单词的长度</h4><ul><li>链接<a href="https://leetcode.cn/problems/length-of-last-word/">https://leetcode.cn/problems/length-of-last-word/</a>  </li><li>解题方法：<br>创建一个临时字符串（用来存每一个单词），和一个答案数组<br>遍历原字符串，如果遍历到空格，判断临时字符串是否为空<br>如果临时字符串非空则说明已经遍历完一个单词，将其加入答案数组中并清空临时字符串<br>如果遍历到的不是空格，将其加入临时字符串中</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLastWord(string s) &#123;</span><br><span class="line">        s += &quot; &quot;;// 在字符串末尾加上一个空格防止遗漏最后一个单词</span><br><span class="line">        string temp;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        for (auto c: s)&#123;</span><br><span class="line">            if (c == &#x27; &#x27;)&#123;</span><br><span class="line">                if (!temp.empty())&#123;</span><br><span class="line">                    res.push_back(temp);</span><br><span class="line">                    temp.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else temp += c;</span><br><span class="line">        &#125;</span><br><span class="line">        if (res.empty()) return 0;</span><br><span class="line">        return res.back().size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="剑指offer-58-左旋转字符串"><a href="#剑指offer-58-左旋转字符串" class="headerlink" title="剑指offer.58 左旋转字符串"></a>剑指offer.58 左旋转字符串</h4><ul><li>链接<a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/</a>  </li><li>解题方法：<br>整体旋转<br>分别旋转前半部分和后半部分</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseLeftWords(string s, int n) &#123;</span><br><span class="line">        reverse(s.begin(), s.end());</span><br><span class="line">        reverse(s.begin(), s.end() - n);</span><br><span class="line">        reverse(s.end() - n, s.end());</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>KMP算法一般用于字符串匹配问题</li><li>例如：给出两个字串 S，P，需要判断 P 串是否为 S 串的子串</li></ul><h3 id="前缀和后缀"><a href="#前缀和后缀" class="headerlink" title="前缀和后缀"></a>前缀和后缀</h3><ul><li>前缀：包含第一个字符不包含最后一个字符（从左往右）</li><li>后缀：包含最后一个字符不包含最后一个字符（从左往右）  </li><li>例如：<strong>a</strong><br>a 既是第一个字符也是最后一个字符，所以不存在前缀和后缀  </li><li>例如：<strong>aa</strong><br>前缀为：a<br>后缀为：a </li><li>例如：<strong>aab</strong><br>前缀为：a, aa<br>后缀为：b, ab</li></ul><h3 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h3><p>前缀表存的是最长相等前后缀的长度<br>例如：aabaaf</p><table><thead><tr><th align="left"></th><th align="left">前缀</th><th align="left">后缀</th><th align="left">最长相等前后缀的长度</th></tr></thead><tbody><tr><td align="left">a</td><td align="left">空</td><td align="left">空</td><td align="left">0</td></tr><tr><td align="left">aa</td><td align="left">a</td><td align="left">a</td><td align="left">1</td></tr><tr><td align="left">aab</td><td align="left">a, aa</td><td align="left">b, ab</td><td align="left">0</td></tr><tr><td align="left">aaba</td><td align="left">a, aa, aab</td><td align="left">a, ba, aba</td><td align="left">1</td></tr><tr><td align="left">aabaa</td><td align="left">a, aa, aab, aaba</td><td align="left">a, aa, baa, abaa</td><td align="left">2</td></tr><tr><td align="left">aabaaf</td><td align="left">a, aa, aab, aaba, aabaa</td><td align="left">f, af, aaf, baaf, abaaf</td><td align="left">0</td></tr></tbody></table><ul><li>在KMP算法当中，用一个 next 数组存的就是以当前字符结尾的最长相等前后缀<br>例如：<strong>aabaaf</strong><br>a: 0, aa: 1, aab: 0, aaba: 1, aabaa: 2<br>next &#x3D; [0, 1, 0, 1, 2]</li></ul><h3 id="前缀表在KMP算法中的作用"><a href="#前缀表在KMP算法中的作用" class="headerlink" title="前缀表在KMP算法中的作用"></a>前缀表在KMP算法中的作用</h3><ul><li>暴力解法中，我们需要两重循环遍历 P 串和 S 串，直到找到匹配的字串，时间复杂度为 O(n*m)，n，m分别表示 P 串和 S 串的长度</li><li>KMP算法的核心思想就是用前缀表记录已经匹配过的文本内容，使得当发生匹配冲突的时候，可以不需要重新遍历，而是通过前缀表回退到之前匹配成功过的位置继续匹配</li></ul><h3 id="next数组的实现（前缀表实现）"><a href="#next数组的实现（前缀表实现）" class="headerlink" title="next数组的实现（前缀表实现）"></a>next数组的实现（前缀表实现）</h3><ul><li>构造 next 数组分为四步：</li></ul><ol><li>初始化<br>  定义两个指针 i，j<br>  i 指向前缀末尾位置，j 指向后缀末尾位置<br>  例如<strong>aabaaf</strong><br>  从 a 开始的时候不存在前缀也不存在后缀，见上表第一行<br>  所以 next 数组初始化为 0，j 从 0 开始，i 从 1 开始</li><li>处理前后缀不相同的情况（冲突的情况）<br>  <code>aabaaf</code><br>  <code>aabaabaaf</code><br>  当发生匹配冲突时（字符 f 和 b 不匹配），j 指针在字符 f 的位置，i 指针在字符 a 的位置，j 应该回退到字符 b 的位置也就是 next[j-1] 的位置继续匹配</li><li>处理前后缀相同的情况<br>  前后缀相同时，j 向后移动一位</li><li>更新 next 数组<br>  将 next 数组更新为 j</li></ol><ul><li>代码模板<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void getNext(vector&lt;int&gt; next, string s) &#123;</span><br><span class="line">        int j = 0;</span><br><span class="line">        next[0] = 0;</span><br><span class="line">        for(int i = 1; i &lt; s.size(); i++) &#123;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; s[i] != s[j]) &#123; // j要保证大于0，因为下面有取j-1作为数组下标的操作</span><br><span class="line">                j = next[j - 1]; </span><br><span class="line">            &#125;</span><br><span class="line">            if (s[i] == s[j]) &#123;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Acwing-831-KMP字符串"><a href="#Acwing-831-KMP字符串" class="headerlink" title="Acwing.831 KMP字符串"></a>Acwing.831 KMP字符串</h4><ul><li>链接<a href="https://www.acwing.com/problem/content/833/">https://www.acwing.com/problem/content/833/</a></li></ul><p>给定一个字符串 S，以及一个模式串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p><p>模式串 P 在字符串 S 中多次作为子串出现。</p><p>求出模式串 P 在字符串 S 中所有出现的位置的起始下标。</p><p><strong>输入格式</strong><br>第一行输入整数 N，表示字符串 P 的长度。</p><p>第二行输入字符串 P。</p><p>第三行输入整数 M，表示字符串 S 的长度。</p><p>第四行输入字符串 S。</p><p><strong>输出格式</strong><br>共一行，输出所有出现位置的起始下标（下标从 0 开始计数），整数之间用空格隔开。</p><p><strong>数据范围</strong><br>1 $\leq$ N $\leq$ $10^{5}$<br>1 $\leq$ M $\leq$ $10^{6}$   </p><p><strong>输入样例：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3  </span><br><span class="line">aba  </span><br><span class="line">5</span><br><span class="line">ababa</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></table></figure><ul><li>解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5 + 10, M = 1e6 + 10;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">char p[N], s[M];</span><br><span class="line">int ne[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    // kmp模板</span><br><span class="line">    ne[0] = 0;</span><br><span class="line">    for (int i = 1, j = 0; i &lt; n; i ++)&#123;</span><br><span class="line">        while (j &gt; 0 &amp;&amp; p[i] != p[j])</span><br><span class="line">            j = ne[j - 1];</span><br><span class="line">        if (p[i] == p[j])</span><br><span class="line">            j ++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    // 两个字符串匹配</span><br><span class="line">    for (int i = 0, j = 0; i &lt; m; i ++)&#123;</span><br><span class="line">        while (j &gt; 0 &amp;&amp; s[i] != p[j])&#123;</span><br><span class="line">            j = ne[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (s[i] == p[j])</span><br><span class="line">            j ++;</span><br><span class="line">        if (j == n) </span><br><span class="line">            cout &lt;&lt; i - n + 1 &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-28-找出字符串中第一个匹配项的下标"><a href="#leetcode-28-找出字符串中第一个匹配项的下标" class="headerlink" title="leetcode.28 找出字符串中第一个匹配项的下标"></a>leetcode.28 找出字符串中第一个匹配项的下标</h4><ul><li>链接<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/</a>  </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int strStr(string s, string p) &#123;</span><br><span class="line">        int n = p.size(), m = s.size();</span><br><span class="line">        vector&lt;int&gt; next(n);</span><br><span class="line">        // kmp模板</span><br><span class="line">        next[0] = 0;</span><br><span class="line">        for (int i = 1, j = 0; i &lt; n; i ++)&#123;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; p[i] != p[j])</span><br><span class="line">                j = next[j - 1];</span><br><span class="line">            if (p[i] == p[j])</span><br><span class="line">                j ++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        // 两个字符串匹配</span><br><span class="line">        for (int i = 0, j = 0; i &lt; m; i ++)&#123;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; s[i] != p[j])</span><br><span class="line">                j = next[j - 1];</span><br><span class="line">            if (s[i] == p[j])</span><br><span class="line">                j ++;</span><br><span class="line">            if (j == n)</span><br><span class="line">                return i - n + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-459-重复的子字符串"><a href="#leetcode-459-重复的子字符串" class="headerlink" title="leetcode.459 重复的子字符串"></a>leetcode.459 重复的子字符串</h4><ul><li>链接<a href="https://leetcode.cn/problems/repeated-substring-pattern/">https://leetcode.cn/problems/repeated-substring-pattern/</a>  </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool repeatedSubstringPattern(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        vector&lt;int&gt; next(n);</span><br><span class="line">        // kmp模板</span><br><span class="line">        next[0] = 0;</span><br><span class="line">        for (int i = 1, j = 0; i &lt; n; i ++)&#123;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; s[i] != s[j])</span><br><span class="line">                j = next[j - 1];</span><br><span class="line">            if (s[i] == s[j])</span><br><span class="line">                j ++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        // 周期</span><br><span class="line">        int t = n - next[n - 1];</span><br><span class="line">        return t &lt; n &amp;&amp; n % t == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-796-旋转字符串"><a href="#leetcode-796-旋转字符串" class="headerlink" title="leetcode.796 旋转字符串"></a>leetcode.796 旋转字符串</h4><ul><li>链接<a href="https://leetcode.cn/problems/rotate-string/">https://leetcode.cn/problems/rotate-string/</a>  </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool rotateString(string s, string p) &#123;</span><br><span class="line">        if (s.size() != p.size()) return false;</span><br><span class="line">        int n = p.size();</span><br><span class="line">        // kmp模板</span><br><span class="line">        vector&lt;int&gt; next(n);</span><br><span class="line">        next[0] = 0;</span><br><span class="line">        for (int i = 1, j = 0; i &lt; n; i ++)&#123;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; p[i] != p[j])</span><br><span class="line">                j = next[j - 1];</span><br><span class="line">            if (p[i] == p[j])</span><br><span class="line">                j ++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        // s+s包括了若干次旋转的可能</span><br><span class="line">        // 字符匹配</span><br><span class="line">        s += s;</span><br><span class="line">        for (int i = 0, j = 0; i &lt; n + n; i ++)&#123;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; s[i] != p[j])</span><br><span class="line">                j = next[j - 1];</span><br><span class="line">            if (s[i] == p[j])</span><br><span class="line">                j ++;</span><br><span class="line">            if (j == n) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2023/01/11/%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/01/11/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h3><ol><li>链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向 null（空指针的意思），链表的入口节点称为链表的头结点也就是 head</li><li>链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理</li><li>由于链表的内存不是连续分布的，所以比较方便进行增加和删除，不方便查询</li><li>链表的定义  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 单链表</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;  // 节点上存储的元素</span><br><span class="line">    ListNode *next;  // 指向下一个节点的指针</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;  // 节点的构造函数</span><br><span class="line">&#125;*head;</span><br></pre></td></tr></table></figure></li></ol><h3 id="链表中常见的面试题型"><a href="#链表中常见的面试题型" class="headerlink" title="链表中常见的面试题型"></a>链表中常见的面试题型</h3><ol><li>设计链表</li><li>链表的基本性质解题</li><li>双指针算法（见双指针算法总结）</li><li>合并链表（归并排序）</li></ol><h4 id="leetcode-707-设计链表"><a href="#leetcode-707-设计链表" class="headerlink" title="leetcode.707 设计链表"></a>leetcode.707 设计链表</h4><ul><li>链接<a href="https://leetcode.cn/problems/design-linked-list/">https://leetcode.cn/problems/design-linked-list/</a>  </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyLinkedList &#123;</span><br><span class="line">public:</span><br><span class="line">    // 定义单链表</span><br><span class="line">    struct ListNode &#123;</span><br><span class="line">        int val;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        ListNode(int _val):val(_val), next(nullptr)&#123;&#125;</span><br><span class="line">    &#125;*head;</span><br><span class="line">    // 链表初始化，头节点为空</span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        head = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取元素</span><br><span class="line">    int get(int index) &#123;</span><br><span class="line">        // 索引无效返回-1</span><br><span class="line">        if (index &lt; 0) return -1;</span><br><span class="line">        // 找到第index个点</span><br><span class="line">        auto p = head;</span><br><span class="line">        for (int i = 0; i &lt; index &amp;&amp; p; i ++) p = p-&gt;next;</span><br><span class="line">        if (!p) return -1;</span><br><span class="line">        return p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    // 在头节点前添加元素</span><br><span class="line">    void addAtHead(int val) &#123;</span><br><span class="line">        auto cur = new ListNode(val);</span><br><span class="line">        cur-&gt;next = head;</span><br><span class="line">        head = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    // 在尾节点后添加元素</span><br><span class="line">    void addAtTail(int val) &#123;</span><br><span class="line">        // 如果头节点不存在，新加入的元素就是头节点</span><br><span class="line">        if (!head) head = new ListNode(val);</span><br><span class="line">        else &#123;</span><br><span class="line">            // 找到尾节点，在后面添加元素</span><br><span class="line">            auto p = head;</span><br><span class="line">            while (p-&gt;next) p = p-&gt;next;</span><br><span class="line">            p-&gt;next = new ListNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 在第index点前添加一个元素</span><br><span class="line">    void addAtIndex(int index, int val) &#123;</span><br><span class="line">        // 如果index&lt;=0，相当于在头节点添加元素</span><br><span class="line">        if (index &lt;= 0) addAtHead(val);</span><br><span class="line">        else &#123;</span><br><span class="line">            // 求链表总长度，如果index等于链表长度相当于在尾节点插入元素</span><br><span class="line">            int len = 0;</span><br><span class="line">            for (auto p = head; p; p = p-&gt;next) len ++;</span><br><span class="line">            if (index == len) addAtTail(val);</span><br><span class="line">            else if (index &lt; len)&#123;</span><br><span class="line">                // 找到第index点的前驱节点，将其插入</span><br><span class="line">                auto p = head;</span><br><span class="line">                for (int i = 0; i &lt; index - 1; i ++) p = p-&gt;next;</span><br><span class="line">                auto cur = new ListNode(val);</span><br><span class="line">                cur-&gt;next = p-&gt;next;</span><br><span class="line">                p-&gt;next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 删除第index个节点</span><br><span class="line">    void deleteAtIndex(int index) &#123;</span><br><span class="line">        int len = 0;</span><br><span class="line">        for (auto p = head; p; p = p-&gt;next) len ++;</span><br><span class="line">        if (index &gt;= 0 &amp;&amp; index &lt; len)&#123;</span><br><span class="line">            // index等于0相当于删除头节点</span><br><span class="line">            if (!index) head = head-&gt;next;</span><br><span class="line">            else &#123;</span><br><span class="line">                auto p = head;</span><br><span class="line">                for (int i = 0; i &lt; index - 1; i ++) p = p-&gt;next;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="line"> * MyLinkedList* obj = new MyLinkedList();</span><br><span class="line"> * int param_1 = obj-&gt;get(index);</span><br><span class="line"> * obj-&gt;addAtHead(val);</span><br><span class="line"> * obj-&gt;addAtTail(val);</span><br><span class="line"> * obj-&gt;addAtIndex(index,val);</span><br><span class="line"> * obj-&gt;deleteAtIndex(index);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-24-两两交换链表中的节点"><a href="#leetcode-24-两两交换链表中的节点" class="headerlink" title="leetcode.24 两两交换链表中的节点"></a>leetcode.24 两两交换链表中的节点</h4><ul><li>链接<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">https://leetcode.cn/problems/swap-nodes-in-pairs/</a>  </li><li>解题方法：画图  </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        auto dummy = new ListNode(-1);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        auto a = dummy;</span><br><span class="line">        while (a-&gt;next &amp;&amp; a-&gt;next-&gt;next)&#123;</span><br><span class="line">            auto b = a-&gt;next;</span><br><span class="line">            auto c = a-&gt;next-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            a-&gt;next = a-&gt;next-&gt;next;</span><br><span class="line">            a-&gt;next-&gt;next = b;</span><br><span class="line">            a-&gt;next-&gt;next-&gt;next = c;</span><br><span class="line"></span><br><span class="line">            a = a-&gt;next-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-237-删除链表中的节点"><a href="#leetcode-237-删除链表中的节点" class="headerlink" title="leetcode.237 删除链表中的节点"></a>leetcode.237 删除链表中的节点</h4><ul><li>链接<a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/">https://leetcode.cn/problems/delete-node-in-a-linked-list/</a>  </li><li>解题方法：<br>本题不是常规意义上的删除节点，无法找到当前节点的前驱节点<br>本题的方法比较取巧，即先把后继节点的值赋值给当前节点，然后再删除后继节点</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void deleteNode(ListNode* node) &#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-19-删除链表的倒数第-N-个结点"><a href="#leetcode-19-删除链表的倒数第-N-个结点" class="headerlink" title="leetcode.19 删除链表的倒数第 N 个结点"></a>leetcode.19 删除链表的倒数第 N 个结点</h4><ul><li>链接<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a>  </li><li>解题方法：<br>常规删除节点的方法，找到倒数第 N 个结点的前驱节点，将第 N 个节点删除</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">        // 防止头节点被删除</span><br><span class="line">        auto dummy = new ListNode(-1);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        // 统计链表长度</span><br><span class="line">        int len = 0;</span><br><span class="line">        for (auto p = dummy; p; p = p-&gt;next) len ++;</span><br><span class="line">        // 找到需要删除节点的前驱节点</span><br><span class="line">        // 倒数第 n 个节点即正数第 len-n 个节点</span><br><span class="line">        // 需要移动 len-n-1 次</span><br><span class="line">        auto p = dummy;</span><br><span class="line">        for (int i = 0; i &lt; len - n - 1; i ++) p = p-&gt;next;</span><br><span class="line">        // 删除节点</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        return dummy-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-21-合并两个有序链表"><a href="#leetcode-21-合并两个有序链表" class="headerlink" title="leetcode.21 合并两个有序链表"></a>leetcode.21 合并两个有序链表</h4><ul><li>链接<a href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a>  </li><li>解题方法：归并排序<br>维护一个当前节点指针<br>如果 list1 的值小于 list2，指针指向 list1 并更新当前节点指针和 list1 的指针<br>如果 list2 的值小于 list1，指针指向 list2 并更新当前节点指针和 list2 的指针<br>如果两个链表长度不同，当一个链表遍历完成，另一个链表没有遍历完成，当前节点指针指向没有遍历完成的链表</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;</span><br><span class="line">        auto dummy = new ListNode(-1);</span><br><span class="line">        auto cur = dummy;</span><br><span class="line">        while (list1 &amp;&amp; list2)&#123;</span><br><span class="line">            if (list1-&gt;val &lt; list2-&gt;val)&#123;</span><br><span class="line">                cur = cur-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                cur = cur-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (list1) cur-&gt;next = list1;</span><br><span class="line">        if (list2) cur-&gt;next = list2;</span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-61-旋转链表"><a href="#leetcode-61-旋转链表" class="headerlink" title="leetcode.61 旋转链表"></a>leetcode.61 旋转链表</h4><ul><li>链接<a href="https://leetcode.cn/problems/rotate-list/">https://leetcode.cn/problems/rotate-list/</a>  </li><li>解题方法：画图  </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* rotateRight(ListNode* head, int k) &#123;</span><br><span class="line">        if (!head) return head;</span><br><span class="line">        // 旋转的次数如果是链表长度的倍数，相当于没有旋转</span><br><span class="line">        int len = 0;</span><br><span class="line">        for (auto p = head; p; p = p-&gt;next) len ++;</span><br><span class="line">        k %= len;</span><br><span class="line">        if (!k) return head;</span><br><span class="line"></span><br><span class="line">        auto p = head;</span><br><span class="line">        for (int i = 0; i &lt; len - k - 1; i ++) p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">        auto tail = head;</span><br><span class="line">        while (tail-&gt;next) tail = tail-&gt;next;</span><br><span class="line"></span><br><span class="line">        tail-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        auto new_head = p-&gt;next;</span><br><span class="line"></span><br><span class="line">        p-&gt;next = nullptr;</span><br><span class="line">        return new_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2023/01/11/%E6%95%B0%E7%BB%84/"/>
      <url>/2023/01/11/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h3><ol><li>数组是存放在连续内存空间上的相同类型数据的集合</li><li>数组下标都是从 0 开始且数组内存空间的地址是连续的</li><li>正是因为数组的在内存空间的地址是连续的，所以数组添加和删除元素是不方便的</li><li>在 c++ 中 vector 的底层实现是 array，严格来讲 vector 是容器，不是数组，数组的元素是不能删的，只能覆盖，STL 中的 erase 函数实际上是将需要删除的元素覆盖掉，再 resize 整个容器的大小释放掉被删除元素的空间，减小 vector 的大小，是一个 O(n) 的操作</li></ol><h3 id="数组中常见的面试题型"><a href="#数组中常见的面试题型" class="headerlink" title="数组中常见的面试题型"></a>数组中常见的面试题型</h3><ol><li>暴力枚举</li><li>双指针算法（见双指针算法总结）</li><li>螺旋矩阵问题</li></ol><h4 id="leetcode-54-螺旋矩阵"><a href="#leetcode-54-螺旋矩阵" class="headerlink" title="leetcode.54 螺旋矩阵"></a>leetcode.54 螺旋矩阵</h4><ul><li>链接<a href="https://leetcode.cn/problems/spiral-matrix/">https://leetcode.cn/problems/spiral-matrix/</a>  </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int n = matrix.size(), m = matrix[0].size();</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; st(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">        // x 表示行，y 表示列</span><br><span class="line">        // 向右移动 x 不变 y+1 </span><br><span class="line">        // 向下移动 y 不变 x+1</span><br><span class="line">        // 向左移动 x 不变 y-1</span><br><span class="line">        // 向上移动 y 不变 x-1</span><br><span class="line">        int dx[4] = &#123;0, 1, 0, -1&#125;, dy[4] = &#123;1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0, x = 0, y = 0, d = 0; i &lt; n * m; i ++)&#123;</span><br><span class="line">            // 将(0, 0)加入答案，并将当前格子状态更新</span><br><span class="line">            res.push_back(matrix[x][y]);</span><br><span class="line">            st[x][y] = true;</span><br><span class="line">            // (a, b)表示下一个位置</span><br><span class="line">            int a = x + dx[d], b = y + dy[d];</span><br><span class="line">            // 如果(a, b)出界了，或者(a, b)格子走过了，则需要转向</span><br><span class="line">            if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || st[a][b])&#123;</span><br><span class="line">                d = (d + 1) % 4;</span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-59-螺旋矩阵-II"><a href="#leetcode-59-螺旋矩阵-II" class="headerlink" title="leetcode.59 螺旋矩阵 II"></a>leetcode.59 螺旋矩阵 II</h4><ul><li>链接<a href="https://leetcode.cn/problems/spiral-matrix-ii/">https://leetcode.cn/problems/spiral-matrix-ii/</a>  </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n));</span><br><span class="line">        int dx[4] = &#123;0, 1, 0, -1&#125;, dy[4] = &#123;1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 1, x = 0, y = 0, d = 0; i &lt;= n * n; i ++)&#123;</span><br><span class="line">            res[x][y] = i;</span><br><span class="line"></span><br><span class="line">            int a = x + dx[d], b = y + dy[d];</span><br><span class="line">            if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n || res[a][b])&#123;</span><br><span class="line">                d = (d + 1) % 4;</span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>哈希表</title>
      <link href="/2023/01/11/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2023/01/11/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h3><ol><li>哈希表是根据关键码的值而直接进行访问的数据结构，又叫做散列表，一般哈希表都是用来快速判断一个元素是否出现集合里</li><li>解决哈希碰撞有两种方法：拉链法，开放寻址法</li><li>常见的哈希结构（c++）set 和 map</li></ol><table><thead><tr><th align="left">集合</th><th align="left">底层实现</th><th align="left">是否有序</th><th align="left">数值是否可以重复</th><th align="left">查询效率</th><th align="left">增删效率</th></tr></thead><tbody><tr><td align="left">std::set</td><td align="left">红黑树</td><td align="left">有序</td><td align="left">否</td><td align="left">O(log n)</td><td align="left">O(log n)</td></tr><tr><td align="left">std::multiset</td><td align="left">红黑树</td><td align="left">有序</td><td align="left">是</td><td align="left">O(logn)</td><td align="left">O(logn)</td></tr><tr><td align="left">std::unordered_set</td><td align="left">哈希表</td><td align="left">无序</td><td align="left">否</td><td align="left">O(1)</td><td align="left">O(1)</td></tr></tbody></table><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><table><thead><tr><th align="left">映射</th><th align="left">底层实现</th><th align="left">是否有序</th><th align="left">key是否可以重复</th><th align="left">查询效率</th><th align="left">增删效率</th></tr></thead><tbody><tr><td align="left">std::map</td><td align="left">红黑树</td><td align="left">key有序</td><td align="left">否</td><td align="left">O(log n)</td><td align="left">O(log n)</td></tr><tr><td align="left">std::multimap</td><td align="left">红黑树</td><td align="left">key有序</td><td align="left">是</td><td align="left">O(logn)</td><td align="left">O(logn)</td></tr><tr><td align="left">std::unordered_map</td><td align="left">哈希表</td><td align="left">key无序</td><td align="left">否</td><td align="left">O(1)</td><td align="left">O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的  </p><p><strong>使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset</strong></p><h3 id="哈希表中常见的面试题型"><a href="#哈希表中常见的面试题型" class="headerlink" title="哈希表中常见的面试题型"></a>哈希表中常见的面试题型</h3><ol><li>利用哈希表（map，set）的性质解题</li><li>双指针算法（滑动窗口）（见双指针算法总结）</li></ol><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="leetcode-242-有效的字母异位词"><a href="#leetcode-242-有效的字母异位词" class="headerlink" title="leetcode.242 有效的字母异位词"></a>leetcode.242 有效的字母异位词</h4><ul><li>链接<a href="https://leetcode.cn/problems/valid-anagram/">https://leetcode.cn/problems/valid-anagram/</a>  </li><li>解题方法：哈希表<br>将两个字符串存入两个哈希表并记录每个字符出现的次数<br>每个字符出现的次数相等则返回true，否则返回false</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123;</span><br><span class="line">        unordered_map&lt;char, int&gt; a, b;</span><br><span class="line">        for (auto c: s) a[c] ++;</span><br><span class="line">        for (auto c: t) b[c] ++;</span><br><span class="line">        return a == b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-383-赎金信"><a href="#leetcode-383-赎金信" class="headerlink" title="leetcode.383 赎金信"></a>leetcode.383 赎金信</h4><ul><li>链接<a href="https://leetcode.cn/problems/ransom-note/">https://leetcode.cn/problems/ransom-note/</a>  </li><li>解题方法：哈希表<br>将字符串 b 存入哈希表，如果字符串 a 中出现了哈希表中没有的字符直接返回 false<br>如果出现了哈希表中存在的字符则哈希表的 value-1</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canConstruct(string ransomNote, string magazine) &#123;</span><br><span class="line">        unordered_map&lt;char, int&gt; hash;</span><br><span class="line">        for (auto c: magazine) hash[c] ++;</span><br><span class="line">        for (auto c: ransomNote)&#123;</span><br><span class="line">            if (!hash[c]) return false;</span><br><span class="line">            hash[c] --;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-1-两数之和"><a href="#leetcode-1-两数之和" class="headerlink" title="leetcode.1 两数之和"></a>leetcode.1 两数之和</h4><ul><li>链接<a href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum/</a>  </li><li>解题方法：哈希表<br>将数组元素存入哈希表，遍历数组求差，差值如果在哈希表中存在则返回下标</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; hash;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i ++)&#123;</span><br><span class="line">            int cur = target - nums[i];</span><br><span class="line">            if (hash.count(cur)) return &#123;hash[cur], i&#125;;</span><br><span class="line">            hash[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-454-四数相加-II"><a href="#leetcode-454-四数相加-II" class="headerlink" title="leetcode.454 四数相加 II"></a>leetcode.454 四数相加 II</h4><ul><li>链接<a href="https://leetcode.cn/problems/4sum-ii/">https://leetcode.cn/problems/4sum-ii/</a>  </li><li>解题方法：哈希表<br><code>a+b+c+d = 0 =&gt; a+b=-(c+d)</code><br>遍历 nums1 nums2 将 a+b 的和 x 存入哈希表，遍历 nums3 nums4 哈希表中有多少个 -x 就说明有多少个符合条件的组合</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; hash;</span><br><span class="line">        int res = 0;</span><br><span class="line"></span><br><span class="line">        for (auto a: nums1)</span><br><span class="line">            for (auto b: nums2)</span><br><span class="line">                hash[a + b] ++;</span><br><span class="line">        </span><br><span class="line">        for (auto c: nums3)</span><br><span class="line">            for (auto d:nums4)</span><br><span class="line">                res += hash[-(c + d)];</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-49-字母异位词分组"><a href="#leetcode-49-字母异位词分组" class="headerlink" title="leetcode.49 字母异位词分组"></a>leetcode.49 字母异位词分组</h4><ul><li>链接<a href="https://leetcode.cn/problems/group-anagrams/">https://leetcode.cn/problems/group-anagrams/</a>  </li><li>解题方法：哈希表<br>哈希表中存{key:[“”,””,””]}<br>例如{“abc”:[“abc”,”acb”,”cba”]}<br>将所有的字符串按字典序排序，如果是字母异位词则一定有相同的字典序<br>如”abc”,”acb”,”cba”它们的字典序都是”abc”<br>key 存字典序，value 存有相同字典序的字符串</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; hash;// &#123;&quot;abc&quot;:[&quot;abc&quot;,[acb],[cab]]&#125;</span><br><span class="line">        </span><br><span class="line">        for (auto str: strs)&#123;</span><br><span class="line">            auto c = str;</span><br><span class="line">            sort(c.begin(), c.end());// 将所有字符串按字典序排序</span><br><span class="line">            hash[c].push_back(str);// 按照字典序把字符串存入哈希表</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        for (auto c: hash) res.push_back(c.second);// 将hash中的value拿出来</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h3><h4 id="leetcode-349-两个数组的交集"><a href="#leetcode-349-两个数组的交集" class="headerlink" title="leetcode.349 两个数组的交集"></a>leetcode.349 两个数组的交集</h4><ul><li>链接<a href="https://leetcode.cn/problems/intersection-of-two-arrays/">https://leetcode.cn/problems/intersection-of-two-arrays/</a>  </li><li>解题方法：哈希集合<br>unordered_set不包含重复元素，key&#x3D;value<br>将 num1 中的元素加入集合中，遍历 nums2 中的元素，如果集合中有相同的元素说明是交集，加入答案数组，并把当前元素从集合中删除</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; set;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">        for (auto c: nums1) set.insert(c);</span><br><span class="line">        for (auto c: nums2)&#123;</span><br><span class="line">            if (set.count(c))&#123;</span><br><span class="line">                res.push_back(c);</span><br><span class="line">                set.erase(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-350-两个数组的交集-II"><a href="#leetcode-350-两个数组的交集-II" class="headerlink" title="leetcode.350 两个数组的交集 II"></a>leetcode.350 两个数组的交集 II</h4><ul><li>链接<a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/submissions/">https://leetcode.cn/problems/intersection-of-two-arrays-ii/submissions/</a>  </li><li>解题方法：哈希集合<br>unordered_multiset可以包含重复元素，key&#x3D;value<br>和上一题思路类似</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_multiset&lt;int&gt; mtset;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">        for (auto c: nums1) mtset.insert(c);</span><br><span class="line">        for (auto c: nums2)&#123;</span><br><span class="line">            if (mtset.count(c))&#123;</span><br><span class="line">                res.push_back(c);</span><br><span class="line">                mtset.erase(mtset.find(c));// 只删除一个c</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-202-快乐数"><a href="#leetcode-202-快乐数" class="headerlink" title="leetcode.202 快乐数"></a>leetcode.202 快乐数</h4><ul><li>链接<a href="https://leetcode.cn/problems/happy-number/submissions/">https://leetcode.cn/problems/happy-number/submissions/</a>  </li><li>解题方法：哈希集合<br>通过集合判断一个数是否重复出现过，如果重复出现说明这个数陷入了循环直接返回 false，否则返回 true</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; set;</span><br><span class="line"></span><br><span class="line">        while (n != 1)&#123;</span><br><span class="line">            int res = 0;</span><br><span class="line">            while (n)&#123;</span><br><span class="line">                res += (n % 10) * (n % 10);</span><br><span class="line">                n /= 10;</span><br><span class="line">            &#125;</span><br><span class="line">            if (set.count(res)) return false;</span><br><span class="line">            set.insert(res);</span><br><span class="line">            n = res;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2023/01/11/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/01/11/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="字符串理论基础"><a href="#字符串理论基础" class="headerlink" title="字符串理论基础"></a>字符串理论基础</h3><ol><li>字符串是若干字符组成的有限序列，也可以理解为是一个字符数组</li></ol><h3 id="数组中常见的面试题型"><a href="#数组中常见的面试题型" class="headerlink" title="数组中常见的面试题型"></a>数组中常见的面试题型</h3><ol><li>双指针算法（见双指针算法总结）</li><li>KMP算法</li></ol><h3 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h3><ul><li>题目类型：给一个字符串组成的句子(带空格或标点)，然后对句中单个字符串进行一系列处理</li><li>这类题目可以分为两类，一类是有前置或者后置空格的，另一类是没有前置和后置空格的</li></ul><h4 id="剑指offer-05-替换空格"><a href="#剑指offer-05-替换空格" class="headerlink" title="剑指offer.05 替换空格"></a>剑指offer.05 替换空格</h4><ul><li>链接<a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">https://leetcode.cn/problems/ti-huan-kong-ge-lcof/</a>  </li><li>解题方法：创建字符串，遍历原字符串找到空格替换即可</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string replaceSpace(string s) &#123;</span><br><span class="line">        string res;</span><br><span class="line">        for (auto c: s)&#123;</span><br><span class="line">            if (c == &#x27; &#x27;)&#123;</span><br><span class="line">                res += &quot;%20&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            else res += c;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-58-最后一个单词的长度"><a href="#leetcode-58-最后一个单词的长度" class="headerlink" title="leetcode.58 最后一个单词的长度"></a>leetcode.58 最后一个单词的长度</h4><ul><li>链接<a href="https://leetcode.cn/problems/length-of-last-word/">https://leetcode.cn/problems/length-of-last-word/</a>  </li><li>解题方法：<br>创建一个临时字符串（用来存每一个单词），和一个答案数组<br>遍历原字符串，如果遍历到空格，判断临时字符串是否为空<br>如果临时字符串非空则说明已经遍历完一个单词，将其加入答案数组中并清空临时字符串<br>如果遍历到的不是空格，将其加入临时字符串中</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLastWord(string s) &#123;</span><br><span class="line">        s += &quot; &quot;;// 在字符串末尾加上一个空格防止遗漏最后一个单词</span><br><span class="line">        string temp = &quot;&quot;;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        for (auto c: s)&#123;</span><br><span class="line">            if (c == &#x27; &#x27;)&#123;</span><br><span class="line">                if (!temp.empty())&#123;</span><br><span class="line">                    res.push_back(temp);</span><br><span class="line">                    temp.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else temp += c;</span><br><span class="line">        &#125;</span><br><span class="line">        if (res.empty()) return 0;</span><br><span class="line">        return res.back().size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="剑指offer-58"><a href="#剑指offer-58" class="headerlink" title="剑指offer.58"></a>剑指offer.58</h4><ul><li>链接<a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/</a>  </li><li>解题方法：整体旋转<br>分别旋转前半部分和后半部分</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseLeftWords(string s, int n) &#123;</span><br><span class="line">        reverse(s.begin(), s.end());</span><br><span class="line">        reverse(s.begin(), s.end() - n);</span><br><span class="line">        reverse(s.end() - n, s.end());</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>KMP算法一般用于字符串匹配问题</li><li>例如：给出两个字串S，P需要判断P串是否为S串的子串</li></ul><h3 id="前缀和后缀"><a href="#前缀和后缀" class="headerlink" title="前缀和后缀"></a>前缀和后缀</h3><ul><li>前缀：包含第一个字符不包含最后一个字符（从左往右）</li><li>后缀：包含最后一个字符不包含最后一个字符（从左往右）  </li><li>例如：<strong>a</strong><br>a 既是第一个字符也是最后一个字符，所以不存在前缀和后缀  </li><li>例如：<strong>aa</strong><br>前缀为：a<br>后缀为：a </li><li>例如：<strong>aab</strong><br>前缀为：a, aa<br>后缀为：b, ab</li></ul><h3 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h3><p>前缀表存的是最长相等前后缀的长度<br>例如：aabaaf</p><table><thead><tr><th align="left"></th><th align="left">前缀</th><th align="left">后缀</th><th align="left">最长相等前后缀的长度</th></tr></thead><tbody><tr><td align="left">a</td><td align="left">空</td><td align="left">空</td><td align="left">0</td></tr><tr><td align="left">aa</td><td align="left">a</td><td align="left">a</td><td align="left">1</td></tr><tr><td align="left">aab</td><td align="left">a, aa</td><td align="left">b, ab</td><td align="left">0</td></tr><tr><td align="left">aaba</td><td align="left">a, aa, aab</td><td align="left">a, ba, aba</td><td align="left">1</td></tr><tr><td align="left">aabaa</td><td align="left">a, aa, aab, aaba</td><td align="left">a, aa, baa, abaa</td><td align="left">2</td></tr><tr><td align="left">aabaaf</td><td align="left">a, aa, aab, aaba, aabaa</td><td align="left">f, af, aaf, baaf, abaaf</td><td align="left">0</td></tr></tbody></table><ul><li>在KMP算法当中，用一个 next 数组存的就是以当前字符结尾的最长相等前后缀<br>例如：<strong>aabaaf</strong><br>a: 0, aa: 1, aab: 0, aaba: 1, aabaa: 2<br>next &#x3D; [0, 1, 0, 1, 2]</li></ul><h3 id="前缀表在KMP算法中的作用"><a href="#前缀表在KMP算法中的作用" class="headerlink" title="前缀表在KMP算法中的作用"></a>前缀表在KMP算法中的作用</h3><ul><li>暴力解法中，我们需要两重循环遍历 P 串和 S 串，直到找到匹配的字串，时间复杂度为 O(n*m)，n，m分别表示 P 串和 S 串的长度</li><li>KMP算法的核心思想就是用前缀表记录已经匹配过的文本内容，使得当发生匹配冲突的时候，可以不需要重新遍历，而是通过前缀表回退到之前匹配成功过的位置继续匹配</li></ul><h3 id="next数组的实现（前缀表实现）"><a href="#next数组的实现（前缀表实现）" class="headerlink" title="next数组的实现（前缀表实现）"></a>next数组的实现（前缀表实现）</h3><ul><li>构造next数组分为四步：</li></ul><ol><li>初始化<br>  定义两个指针 i，j<br>  i 指向前缀末尾位置，j 指向后缀末尾位置<br>  例如<strong>aabaaf</strong><br>  从 a 开始的时候不存在前缀也不存在后缀，见上表第一行<br>  所以 next 数组初始化为 0，j 从 0 开始，i 从 1 开始</li><li>处理前后缀不相同的情况（冲突的情况）<br>  <code>aabaaf</code><br>  <code>aabaabaaf</code><br>  当发生匹配冲突时（字符f 和 b 不匹配），j 指针在字符 f 的位置，i 指针在字符 a 的位置，j 应该回退到 next[j-1] 的位置继续匹配</li><li>处理前后缀相同的情况<br>  前后缀相同时，j 向后移动一位</li><li>更新 next 数组<br>  将 next 数组更新为 j</li></ol><ul><li>代码模板<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void getNext(vector&lt;int&gt; next, string s) &#123;</span><br><span class="line">        int j = 0;</span><br><span class="line">        next[0] = 0;</span><br><span class="line">        for(int i = 1; i &lt; s.size(); i++) &#123;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; s[i] != s[j]) &#123; // j要保证大于0，因为下面有取j-1作为数组下标的操作</span><br><span class="line">                j = next[j - 1]; // 注意这里，是要找前一位的对应的回退位置了</span><br><span class="line">            &#125;</span><br><span class="line">            if (s[i] == s[j]) &#123;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-28-找出字符串中第一个匹配项的下标"><a href="#leetcode-28-找出字符串中第一个匹配项的下标" class="headerlink" title="leetcode.28 找出字符串中第一个匹配项的下标"></a>leetcode.28 找出字符串中第一个匹配项的下标</h4><ul><li>链接<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/</a>  </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int strStr(string s, string p) &#123;</span><br><span class="line">        if (p.empty()) return 0;</span><br><span class="line">        int n = s.size(), m = p.size();</span><br><span class="line">        // kmp模板</span><br><span class="line">        vector&lt;int&gt; next(m);</span><br><span class="line">        int j = 0;</span><br><span class="line">        next[0] = 0;</span><br><span class="line">        for (int i = 1; i &lt; m; i ++)&#123;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; p[i] != p[j])</span><br><span class="line">                j = next[j - 1];</span><br><span class="line">            if (p[i] == p[j])</span><br><span class="line">                j ++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        // 两个字符串进行匹配</span><br><span class="line">        j = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i ++)&#123;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; s[i] != p[j])</span><br><span class="line">                j = next[j - 1];</span><br><span class="line">            if (s[i] == p[j])</span><br><span class="line">                j ++;</span><br><span class="line">            if (j == m) return i - m + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-459-重复的子字符串"><a href="#leetcode-459-重复的子字符串" class="headerlink" title="leetcode.459 重复的子字符串"></a>leetcode.459 重复的子字符串</h4><ul><li>链接<a href="https://leetcode.cn/problems/repeated-substring-pattern/">https://leetcode.cn/problems/repeated-substring-pattern/</a>  </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool repeatedSubstringPattern(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        // kmp模板</span><br><span class="line">        vector&lt;int&gt; next(n);</span><br><span class="line">        int j = 0;</span><br><span class="line">        next[0] = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; i ++)&#123;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; s[i] != s[j])</span><br><span class="line">                j = next[j - 1];</span><br><span class="line">            if (s[i] == s[j])</span><br><span class="line">                j ++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        // 周期</span><br><span class="line">        int t = n - next[n - 1];</span><br><span class="line">        return t &lt; n &amp;&amp; n % t == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-796-旋转字符串"><a href="#leetcode-796-旋转字符串" class="headerlink" title="leetcode.796 旋转字符串"></a>leetcode.796 旋转字符串</h4><ul><li>链接<a href="https://leetcode.cn/problems/rotate-string/">https://leetcode.cn/problems/rotate-string/</a>  </li><li>解题方法：kmp算法</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool rotateString(string s, string p) &#123;</span><br><span class="line">        if (s.size() != p.size()) return false;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        // kmp模板</span><br><span class="line">        vector&lt;int&gt; next(n);</span><br><span class="line">        int j = 0;</span><br><span class="line">        next[0] = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; i ++)&#123;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; p[i] != p[j])</span><br><span class="line">                j = next[j - 1];</span><br><span class="line">            if (p[i] == p[j])</span><br><span class="line">                j ++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        // s+s包括了若干次旋转的可能</span><br><span class="line">        // 字符匹配</span><br><span class="line">        s += s;</span><br><span class="line">        j = 0;</span><br><span class="line">        for (int i = 0; i &lt; n + n; i ++)&#123;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; s[i] != p[j])</span><br><span class="line">                j = next[j - 1];</span><br><span class="line">            if (s[i] == p[j])</span><br><span class="line">                j ++;</span><br><span class="line">            if (j == n) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2023/01/11/%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/01/11/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h3><ol><li>链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向 null（空指针的意思），链表的入口节点称为链表的头结点也就是 head</li><li>链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理</li><li>由于链表的内存不是连续分布的，所以比较方便进行增加和删除，不方便查询</li><li>链表的定义  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 单链表</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;  // 节点上存储的元素</span><br><span class="line">    ListNode *next;  // 指向下一个节点的指针</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;  // 节点的构造函数</span><br><span class="line">&#125;*head;</span><br></pre></td></tr></table></figure></li></ol><h3 id="链表中常见的面试题型"><a href="#链表中常见的面试题型" class="headerlink" title="链表中常见的面试题型"></a>链表中常见的面试题型</h3><ol><li>设计链表</li><li>链表的基本性质解题</li><li>双指针算法（见双指针算法总结）</li><li>合并链表（归并排序）</li></ol><h4 id="leetcode-707-设计链表"><a href="#leetcode-707-设计链表" class="headerlink" title="leetcode.707 设计链表"></a>leetcode.707 设计链表</h4><ul><li>链接<a href="https://leetcode.cn/problems/design-linked-list/">https://leetcode.cn/problems/design-linked-list/</a>  </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyLinkedList &#123;</span><br><span class="line">public:</span><br><span class="line">    // 定义单链表</span><br><span class="line">    struct ListNode &#123;</span><br><span class="line">        int val;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        ListNode(int _val):val(_val), next(nullptr)&#123;&#125;</span><br><span class="line">    &#125;*head;</span><br><span class="line">    // 链表初始化，头节点为空</span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        head = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取元素</span><br><span class="line">    int get(int index) &#123;</span><br><span class="line">        // 索引无效返回-1</span><br><span class="line">        if (index &lt; 0) return -1;</span><br><span class="line">        // 找到第index个点</span><br><span class="line">        auto p = head;</span><br><span class="line">        for (int i = 0; i &lt; index &amp;&amp; p; i ++) p = p-&gt;next;</span><br><span class="line">        if (!p) return -1;</span><br><span class="line">        return p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    // 在头节点前添加元素</span><br><span class="line">    void addAtHead(int val) &#123;</span><br><span class="line">        auto cur = new ListNode(val);</span><br><span class="line">        cur-&gt;next = head;</span><br><span class="line">        head = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    // 在尾节点后添加元素</span><br><span class="line">    void addAtTail(int val) &#123;</span><br><span class="line">        // 如果头节点不存在，新加入的元素就是头节点</span><br><span class="line">        if (!head) head = new ListNode(val);</span><br><span class="line">        else &#123;</span><br><span class="line">            // 找到尾节点，在后面添加元素</span><br><span class="line">            auto p = head;</span><br><span class="line">            while (p-&gt;next) p = p-&gt;next;</span><br><span class="line">            p-&gt;next = new ListNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 在第index点前添加一个元素</span><br><span class="line">    void addAtIndex(int index, int val) &#123;</span><br><span class="line">        // 如果index&lt;=0，相当于在头节点添加元素</span><br><span class="line">        if (index &lt;= 0) addAtHead(val);</span><br><span class="line">        else &#123;</span><br><span class="line">            // 求链表总长度，如果index等于链表长度相当于在尾节点插入元素</span><br><span class="line">            int len = 0;</span><br><span class="line">            for (auto p = head; p; p = p-&gt;next) len ++;</span><br><span class="line">            if (index == len) addAtTail(val);</span><br><span class="line">            else if (index &lt; len)&#123;</span><br><span class="line">                // 找到第index点的前驱节点，将其插入</span><br><span class="line">                auto p = head;</span><br><span class="line">                for (int i = 0; i &lt; index - 1; i ++) p = p-&gt;next;</span><br><span class="line">                auto cur = new ListNode(val);</span><br><span class="line">                cur-&gt;next = p-&gt;next;</span><br><span class="line">                p-&gt;next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 删除第index个节点</span><br><span class="line">    void deleteAtIndex(int index) &#123;</span><br><span class="line">        int len = 0;</span><br><span class="line">        for (auto p = head; p; p = p-&gt;next) len ++;</span><br><span class="line">        if (index &gt;= 0 &amp;&amp; index &lt; len)&#123;</span><br><span class="line">            // index等于0相当于删除头节点</span><br><span class="line">            if (!index) head = head-&gt;next;</span><br><span class="line">            else &#123;</span><br><span class="line">                auto p = head;</span><br><span class="line">                for (int i = 0; i &lt; index - 1; i ++) p = p-&gt;next;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="line"> * MyLinkedList* obj = new MyLinkedList();</span><br><span class="line"> * int param_1 = obj-&gt;get(index);</span><br><span class="line"> * obj-&gt;addAtHead(val);</span><br><span class="line"> * obj-&gt;addAtTail(val);</span><br><span class="line"> * obj-&gt;addAtIndex(index,val);</span><br><span class="line"> * obj-&gt;deleteAtIndex(index);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-24-两两交换链表中的节点"><a href="#leetcode-24-两两交换链表中的节点" class="headerlink" title="leetcode.24 两两交换链表中的节点"></a>leetcode.24 两两交换链表中的节点</h4><ul><li>链接<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">https://leetcode.cn/problems/swap-nodes-in-pairs/</a>  </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        // 头节点可能会改变</span><br><span class="line">        auto dummy = new ListNode(-1);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        auto a = dummy;</span><br><span class="line">        while (a-&gt;next &amp;&amp; a-&gt;next-&gt;next)&#123;</span><br><span class="line">            auto b = a-&gt;next;</span><br><span class="line">            auto c = a-&gt;next-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            a-&gt;next = a-&gt;next-&gt;next;</span><br><span class="line">            a-&gt;next-&gt;next = b;</span><br><span class="line">            a-&gt;next-&gt;next-&gt;next = c;</span><br><span class="line"></span><br><span class="line">            a = a-&gt;next-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-237-删除链表中的节点"><a href="#leetcode-237-删除链表中的节点" class="headerlink" title="leetcode.237 删除链表中的节点"></a>leetcode.237 删除链表中的节点</h4><ul><li>链接<a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/">https://leetcode.cn/problems/delete-node-in-a-linked-list/</a>  </li><li>解题方法：本题不是常规意义上的删除节点，无法像上一道题一样找到当前节点的前驱节点<br>本题的方法比较取巧，即先把后继节点的值赋值给当前节点，然后再删除后继节点</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void deleteNode(ListNode* node) &#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-19-删除链表的倒数第-N-个结点"><a href="#leetcode-19-删除链表的倒数第-N-个结点" class="headerlink" title="leetcode.19 删除链表的倒数第 N 个结点"></a>leetcode.19 删除链表的倒数第 N 个结点</h4><ul><li>链接<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a>  </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">        // 防止头节点被删除</span><br><span class="line">        auto dummy = new ListNode(-1);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        // 统计链表长度</span><br><span class="line">        int len = 0;</span><br><span class="line">        for (auto p = dummy; p; p = p-&gt;next) len ++;</span><br><span class="line">        // 找到需要删除节点的前驱节点</span><br><span class="line">        // 倒数第 n 个节点即正数第 len-n 个节点</span><br><span class="line">        // 需要移动 len-n-1 次</span><br><span class="line">        auto p = dummy;</span><br><span class="line">        for (int i = 0; i &lt; len - n - 1; i ++) p = p-&gt;next;</span><br><span class="line">        // 删除节点</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        return dummy-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-21-合并两个有序链表"><a href="#leetcode-21-合并两个有序链表" class="headerlink" title="leetcode.21 合并两个有序链表"></a>leetcode.21 合并两个有序链表</h4><ul><li>链接<a href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a>  </li><li>解题方法：归并排序<br>维护一个当前节点指针<br>如果 list1 的值小于 list2，指针指向 list1 并更新当前节点指针和 list1 的指针<br>如果 list2 的值小于 list1，指针指向 list2 并更新当前节点指针和 list2 的指针<br>如果两个链表长度不同，当一个链表遍历完成，另一个链表没有遍历完成，当前节点指针指向没有遍历完成的链表</li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;</span><br><span class="line">        auto dummy = new ListNode(-1);</span><br><span class="line">        auto cur = dummy;</span><br><span class="line">        while (list1 &amp;&amp; list2)&#123;</span><br><span class="line">            if (list1-&gt;val &lt; list2-&gt;val)&#123;</span><br><span class="line">                cur = cur-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                cur = cur-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (list1) cur-&gt;next = list1;</span><br><span class="line">        if (list2) cur-&gt;next = list2;</span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-23-合并K个升序链表"><a href="#leetcode-23-合并K个升序链表" class="headerlink" title="leetcode.23 合并K个升序链表"></a>leetcode.23 合并K个升序链表</h4><ul><li>链接<a href="https://leetcode.cn/problems/merge-k-sorted-lists/">https://leetcode.cn/problems/merge-k-sorted-lists/</a>  </li><li>解题方法：归并排序与上一题类似<br>如何从 k 个链表中找到最小的值呢？维护一个堆<br>在 c++ 中维护一个堆用 priority_queue，默认是大根堆，所以还需要重载一下比较函数  </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 重载比较函数，将小的元素放在堆顶，大的元素放在堆底</span><br><span class="line">    struct Cmp&#123;</span><br><span class="line">        bool operator() (ListNode* a, ListNode* b)&#123;</span><br><span class="line">            return a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, Cmp&gt; heap;</span><br><span class="line">        auto dummy = new ListNode(-1);</span><br><span class="line">        auto cur = dummy;</span><br><span class="line">        // 将所有链表数组入堆，会自动排序将头元素进行排序</span><br><span class="line">        for (auto c: lists) </span><br><span class="line">            if (c) heap.push(c);</span><br><span class="line"></span><br><span class="line">        while (heap.size())&#123;</span><br><span class="line">            auto t = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next = t;</span><br><span class="line">            if (t-&gt;next) heap.push(t-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-61-旋转链表"><a href="#leetcode-61-旋转链表" class="headerlink" title="leetcode.61 旋转链表"></a>leetcode.61 旋转链表</h4><ul><li>链接<a href="https://leetcode.cn/problems/rotate-list/">https://leetcode.cn/problems/rotate-list/</a>  </li><li>解题方法：画图  </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* rotateRight(ListNode* head, int k) &#123;</span><br><span class="line">        if (!head) return head;</span><br><span class="line">        // 旋转的次数如果是链表长度的倍数，相当于没有旋转</span><br><span class="line">        int len = 0;</span><br><span class="line">        for (auto p = head; p; p = p-&gt;next) len ++;</span><br><span class="line">        k %= len;</span><br><span class="line">        if (!k) return head;</span><br><span class="line">        // 1.找到倒数第k+1个点（新链表的尾节点）</span><br><span class="line">        auto p = head;</span><br><span class="line">        for (int i = 0; i &lt; len - k - 1; i ++) p = p-&gt;next;</span><br><span class="line">        // 2.找到原链表的尾节点</span><br><span class="line">        auto tail = head;</span><br><span class="line">        while (tail-&gt;next) tail = tail-&gt;next;</span><br><span class="line">        // 3.将原链表的尾节点指向原链表的头节点</span><br><span class="line">        tail-&gt;next = head;</span><br><span class="line">        // 4.找到新链表的头节点（新链表的尾节点的下一个节点）</span><br><span class="line">        auto new_head = p-&gt;next;</span><br><span class="line">        // 5.将新链表的尾节点指向空</span><br><span class="line">        p-&gt;next = nullptr;</span><br><span class="line">        return new_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2023/01/11/%E6%95%B0%E7%BB%84/"/>
      <url>/2023/01/11/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h3><ol><li>数组是存放在连续内存空间上的相同类型数据的集合</li><li>数组下标都是从 0 开始且数组内存空间的地址是连续的</li><li>正是因为数组的在内存空间的地址是连续的，所以数组添加和删除元素是不方便的</li><li>在 c++ 中 vector 的底层实现是 array，严格来讲 vector 是容器，不是数组，数组的元素是不能删的，只能覆盖，STL 中的 erase 函数实际上是将需要删除的元素覆盖掉，再 resize 整个容器的大小释放掉被删除元素的空间，减小 vector 的大小，是一个 O(n) 的操作</li></ol><h3 id="数组中常见的面试题型"><a href="#数组中常见的面试题型" class="headerlink" title="数组中常见的面试题型"></a>数组中常见的面试题型</h3><ol><li>暴力枚举</li><li>双指针算法（见双指针算法总结）</li><li>螺旋矩阵问题</li></ol><h4 id="leetcode-54-螺旋矩阵"><a href="#leetcode-54-螺旋矩阵" class="headerlink" title="leetcode.54 螺旋矩阵"></a>leetcode.54 螺旋矩阵</h4><ul><li>链接<a href="https://leetcode.cn/problems/spiral-matrix/">https://leetcode.cn/problems/spiral-matrix/</a>  </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int n = matrix.size(), m = matrix[0].size();</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; st(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">        // x 表示行，y 表示列</span><br><span class="line">        // 向右移动 x 不变 y+1 </span><br><span class="line">        // 向下移动 y 不变 x+1</span><br><span class="line">        // 向左移动 x 不变 y-1</span><br><span class="line">        // 向上移动 y 不变 x-1</span><br><span class="line">        int dx[4] = &#123;0, 1, 0, -1&#125;, dy[4] = &#123;1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0, x = 0, y = 0, d = 0; i &lt; n * m; i ++)&#123;</span><br><span class="line">            // 将(0, 0)加入答案，并将当前格子状态更新</span><br><span class="line">            res.push_back(matrix[x][y]);</span><br><span class="line">            st[x][y] = true;</span><br><span class="line">            // (a, b)表示下一个位置</span><br><span class="line">            int a = x + dx[d], b = y + dy[d];</span><br><span class="line">            // 如果(a, b)出界了，或者(a, b)格子走过了，则需要转向</span><br><span class="line">            if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || st[a][b])&#123;</span><br><span class="line">                d = (d + 1) % 4;</span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-59-螺旋矩阵-II"><a href="#leetcode-59-螺旋矩阵-II" class="headerlink" title="leetcode.59 螺旋矩阵 II"></a>leetcode.59 螺旋矩阵 II</h4><ul><li>链接<a href="https://leetcode.cn/problems/spiral-matrix-ii/">https://leetcode.cn/problems/spiral-matrix-ii/</a>  </li><li>leetcode解题代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n));</span><br><span class="line">        int dx[4] = &#123;0, 1, 0, -1&#125;, dy[4] = &#123;1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 1, x = 0, y = 0, d = 0; i &lt;= n * n; i ++)&#123;</span><br><span class="line">            res[x][y] = i;</span><br><span class="line"></span><br><span class="line">            int a = x + dx[d], b = y + dy[d];</span><br><span class="line">            if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n || res[a][b])&#123;</span><br><span class="line">                d = (d + 1) % 4;</span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/10/hello-world/"/>
      <url>/2023/01/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
